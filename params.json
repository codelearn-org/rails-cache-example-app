{"name":"Caching demo app","tagline":"A simple hack to demonstrate caching in rails","body":"#Cache in Rails#\r\n\r\nWeb cache is a mechanism used for storing web documents such as HTML pages and images to reduce the bandwidth and server load. In Ruby on Rails there are mainly 3 types of caching used namely Page caching, Action Caching and Fragment Caching\r\n\r\n#Page Caching#\r\n\r\nIn page caching whenever a request is sent by a user to the server, the web server would check for the generated cached page and if that exists it would be served. Hence the rails app won't have to process it again thereby saving bandwidth and avoids load on the server. This type of caching is lightning fast, but one main disadvantage of this is that this can't be used for caching every page. As the requests don't go to the rails app, the authentication and access restrictions using `before_filter` wont work if page caching is used.\r\n\r\nConsider an example where a page relies on the user's settings. If we cache this page, another user won't get the customized settings but only be able to get the cached copy of the page.\r\n\r\neg for Page caching:\r\n\r\n```\r\nClass UserController < ActionController\r\n\r\n  caches_page :profile\r\n\r\n  def profile\r\n    @user = current_user\r\n  end\r\n\r\nend\r\n```\r\n\r\nTo expire the cache when an update is made, we will have to call an `expire_page` action\r\neg :\r\n\r\n```\r\nClass UserController < ActionController\r\n\r\n  caches_page :profile\r\n\r\n  def profile\r\n    @user = current_user\r\n  end\r\n\r\n  def update\r\n    expire_page :action=> profile\r\n  end\r\n\r\nend\r\n```\r\n\r\n\r\n#Action Caching#\r\n\r\nIn action caching the disadvantages of page caching won't be a problem as all the requests will be sent to the rails app via the web-server  Hence the authentication and access restrictions using the before_filters can be applied before serving a page. Action Caching is done similar to page caching in terms of code.\r\neg:\r\n\r\n```\r\nclass UserController < ActionController\r\n\r\n  before_filter :authenticate\r\n  caches_action :profile\r\n\r\n  def profile\r\n    @user = current_user\r\n  end\r\n\r\n  def update\r\n    expire_action :action => :profile\r\n  end\r\n\r\nend\r\n```\r\n\r\n\r\n#Fragment Caching#\r\n\r\nFragment Caching is mainly used for dynamic pages. In this type of caching fragments of a page can be cached and expired.\r\n\r\nConsider an example in which an article is posted to a blog and a reader wants to post a comment to it. Since the article is the same this can be cached while the comments will be dynamic in nature  as he posts his comment that should be displayed. In this case we can use fragment caching for posts\r\n\r\neg:\r\n```\r\n<% cache do %>\r\n  <%= render article %>\r\n<% end %>\r\n\r\n<% @article.comments.each do |comments| %>\r\n  <%= comments.user_name %>\r\n  <%= comments.user_comment %>\r\n<% end %>\r\n```\r\n\r\nHere the article would be cached while the comments wont.\r\n\r\n\r\n#SQL Caching#\r\n\r\nSQL Caching will cache any SQL results performed by the Active Records or Data mappers so that if the same query is doesn't hit the database again and thereby decreasing the load time.\r\nEg:\r\n```\r\nclass ArticleController < ActionController\r\n\r\n  def index\r\n    @artilces = Article.all\r\n\r\n    # Run the same query again\r\n    @articles = Article.all # will pull the data from the memory and not from DB\r\n  end\r\n\r\nend\r\n```\r\n\r\n\r\n#Russian Doll Caching (Rails 4)#\r\n\r\nIn Russian Doll Caching nested fragment caches are used, so that the caches can be reused again. In Russian Doll caching, if a fragment change at the top level then only that fragment is expired instead of expiring the whole fragment. Thus we can reuse that cache.\r\n\r\nEg:\r\n```\r\nclass Article < ActiveRecord::Base\r\n  has_many :comments\r\nend\r\n\r\nclass Comments < ActiveRecord::Base\r\n  belongs_to :articles, touch: true\r\nend\r\n```\r\nThe `touch` option for `belongs_to` model will make sure that whenever the article changes the cache will be updated in the comments too.\r\n\r\nTo demonstrate the concepts of caching in rails I have made a simple blog hack. Here the index action in home_controller.rb will render home page if the users aren't signed in else the signed in users will be redirected to the articles index action, where the articles will be displayed. In order to perform page caching, just add `caches_page` to the the home_controller.rb\r\n\r\nEg:\r\n```\r\nclass HomeController < ApplicationController\r\n  caches_page :index\r\n\r\n  def index\r\n    redirect_to articles_path if user_signed_in?\r\n  end\r\n\r\nend\r\n```\r\n\r\nAn example of action caching can be found on the articles_controller.rb, where we can perform caching on the index, show actions.\r\nHere as long as a new article is posted, edited or destroyed the contents of the index and show will remain the same. Hence we action caching would be the best in this case.\r\n\r\nEg:\r\n\r\n```\r\nclass ArticlesController < ApplicationController\r\n  before_filter :authenticate_user!\r\n  caches_action :index, :show\r\n\r\n  def index\r\n    @articles = Article.all\r\n  end\r\n\r\n  def show\r\n    @article = Article.find(params[:id])\r\n  end\r\n\r\nend\r\n```\r\n\r\nBut we need to make sure that the cache is expired whenever an article changes. So we also need to add `expire_action` to actions in articles_controller.rb\r\n\r\nEg:\r\n\r\n```\r\nclass ArticlesController < ApplicationController\r\n  before_filter :authenticate_user!\r\n  caches_action :index, :show\r\n\r\n  def index\r\n    @articles = Article.all\r\n  end\r\n\r\n  def show\r\n    @article = Article.find(params[:id])\r\n  end\r\n\r\n  def create\r\n    @article = Article.new(params[:article])\r\n    if @article.save\r\n      expire_action :action => [:index,:show] #expire the cache whenever a new article is posted\r\n    end\r\n  end\r\n\r\nend\r\n```\r\n\r\nThe index action also uses the  SQL caching mechanism in rails. The `Article.all` will run an Active Record query to fetch all the articles from the database and will create a cache for this query. If the same query is repeated the cached result will be used instead of querying the database again.\r\n\r\n\r\n#What happens when inappropriate caching is used ?#\r\n\r\nConsider the case, when page caching was used for the index action instead of action caching in the articles_controller.rb. Whenever a user clicks on the index link, a cached copy if the index page would be rendered to him, even if he is not signed in. Thus the purpose of authentication will be lost if inappropriate caching methods are used for your actions.\r\n\r\n\r\nYou can always try out the app in codelearns playground. Just fork the repo. Navigate to the app directory (cd <app_folder>), bundle install to make sure all dependencies are satisfied. Then simply start the server using the rails s command and you will have the app running in your browser.\r\n\r\nYou can find the whole app at [github](https://github.com/manusajith/caching_demo_app/ \"Demo App\").\r\nand is hosted on [heroku](http://caching-example.herokuapp.com/ \"Heroku\").\r\nPS: The Demo App was created using scaffolded code and is just meant for demonstrating the caching mechanism in rails. User authentication and UI wasn't give much importance. If someone has spare time and is willing to contribute the pull-requests are always welcome :)\r\n\r\n--\r\n<br>\r\nManu S Ajith\r\n<br>\r\n[GitHub](https://github.com/manusajith/ \"Github\") | [Twitter](https://twitter.com/manusajith/ \"Twitter\")\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}