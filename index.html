<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Caching demo app by manusajith</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Caching demo app</h1>
        <h2>A simple hack to demonstrate caching in rails</h2>
        <a href="https://github.com/manusajith/caching_demo_app" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>Cache in Rails</h1>

<p>Web cache is a mechanism used for storing web documents such as HTML pages and images to reduce the bandwidth and server load. In Ruby on Rails there are mainly 3 types of caching used namely Page caching, Action Caching and Fragment Caching</p>

<h1>Page Caching</h1>

<p>In page caching whenever a request is sent by a user to the server, the web server would check for the generated cached page and if that exists it would be served. Hence the rails app won't have to process it again thereby saving bandwidth and avoids load on the server. This type of caching is lightning fast, but one main disadvantage of this is that this can't be used for caching every page. As the requests don't go to the rails app, the authentication and access restrictions using <code>before_filter</code> wont work if page caching is used.</p>

<p>Consider an example where a page relies on the user's settings. If we cache this page, another user won't get the customized settings but only be able to get the cached copy of the page.</p>

<p>eg for Page caching:</p>

<pre><code>Class UserController &lt; ActionController

  caches_page :profile

  def profile
    @user = current_user
  end

end
</code></pre>

<p>To expire the cache when an update is made, we will have to call an <code>expire_page</code> action
eg :</p>

<pre><code>Class UserController &lt; ActionController

  caches_page :profile

  def profile
    @user = current_user
  end

  def update
    expire_page :action=&gt; profile
  end

end
</code></pre>

<h1>Action Caching</h1>

<p>In action caching the disadvantages of page caching won't be a problem as all the requests will be sent to the rails app via the web-server  Hence the authentication and access restrictions using the before_filters can be applied before serving a page. Action Caching is done similar to page caching in terms of code.
eg:</p>

<pre><code>class UserController &lt; ActionController

  before_filter :authenticate
  caches_action :profile

  def profile
    @user = current_user
  end

  def update
    expire_action :action =&gt; :profile
  end

end
</code></pre>

<h1>Fragment Caching</h1>

<p>Fragment Caching is mainly used for dynamic pages. In this type of caching fragments of a page can be cached and expired.</p>

<p>Consider an example in which an article is posted to a blog and a reader wants to post a comment to it. Since the article is the same this can be cached while the comments will be dynamic in nature  as he posts his comment that should be displayed. In this case we can use fragment caching for posts</p>

<p>eg:</p>

<pre><code>&lt;% cache do %&gt;
  &lt;%= render article %&gt;
&lt;% end %&gt;

&lt;% @article.comments.each do |comments| %&gt;
  &lt;%= comments.user_name %&gt;
  &lt;%= comments.user_comment %&gt;
&lt;% end %&gt;
</code></pre>

<p>Here the article would be cached while the comments wont.</p>

<h1>SQL Caching</h1>

<p>SQL Caching will cache any SQL results performed by the Active Records or Data mappers so that if the same query is doesn't hit the database again and thereby decreasing the load time.
Eg:</p>

<pre><code>class ArticleController &lt; ActionController

  def index
    @artilces = Article.all

    # Run the same query again
    @articles = Article.all # will pull the data from the memory and not from DB
  end

end
</code></pre>

<h1>Russian Doll Caching (Rails 4)</h1>

<p>In Russian Doll Caching nested fragment caches are used, so that the caches can be reused again. In Russian Doll caching, if a fragment change at the top level then only that fragment is expired instead of expiring the whole fragment. Thus we can reuse that cache.</p>

<p>Eg:</p>

<pre><code>class Article &lt; ActiveRecord::Base
  has_many :comments
end

class Comments &lt; ActiveRecord::Base
  belongs_to :articles, touch: true
end
</code></pre>

<p>The <code>touch</code> option for <code>belongs_to</code> model will make sure that whenever the article changes the cache will be updated in the comments too.</p>

<p>To demonstrate the concepts of caching in rails I have made a simple blog hack. Here the index action in home_controller.rb will render home page if the users aren't signed in else the signed in users will be redirected to the articles index action, where the articles will be displayed. In order to perform page caching, just add <code>caches_page</code> to the the home_controller.rb</p>

<p>Eg:</p>

<pre><code>class HomeController &lt; ApplicationController
  caches_page :index

  def index
    redirect_to articles_path if user_signed_in?
  end

end
</code></pre>

<p>An example of action caching can be found on the articles_controller.rb, where we can perform caching on the index, show actions.
Here as long as a new article is posted, edited or destroyed the contents of the index and show will remain the same. Hence we action caching would be the best in this case.</p>

<p>Eg:</p>

<pre><code>class ArticlesController &lt; ApplicationController
  before_filter :authenticate_user!
  caches_action :index, :show

  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

end
</code></pre>

<p>But we need to make sure that the cache is expired whenever an article changes. So we also need to add <code>expire_action</code> to actions in articles_controller.rb</p>

<p>Eg:</p>

<pre><code>class ArticlesController &lt; ApplicationController
  before_filter :authenticate_user!
  caches_action :index, :show

  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def create
    @article = Article.new(params[:article])
    if @article.save
      expire_action :action =&gt; [:index,:show] #expire the cache whenever a new article is posted
    end
  end

end
</code></pre>

<p>The index action also uses the  SQL caching mechanism in rails. The <code>Article.all</code> will run an Active Record query to fetch all the articles from the database and will create a cache for this query. If the same query is repeated the cached result will be used instead of querying the database again.</p>

<h1>What happens when inappropriate caching is used ?</h1>

<p>Consider the case, when page caching was used for the index action instead of action caching in the articles_controller.rb. Whenever a user clicks on the index link, a cached copy if the index page would be rendered to him, even if he is not signed in. Thus the purpose of authentication will be lost if inappropriate caching methods are used for your actions.</p>

<p>You can always try out the app in codelearns playground. Just fork the repo. Navigate to the app directory (cd ), bundle install to make sure all dependencies are satisfied. Then simply start the server using the rails s command and you will have the app running in your browser.</p>

<p>You can find the whole app at <a href="https://github.com/manusajith/caching_demo_app/" title="Demo App">github</a>.
and is hosted on <a href="http://caching-example.herokuapp.com/" title="Heroku">heroku</a>.
PS: The Demo App was created using scaffolded code and is just meant for demonstrating the caching mechanism in rails. User authentication and UI wasn't give much importance. If someone has spare time and is willing to contribute the pull-requests are always welcome :)</p>

<h2></h2>

<p><br>
Manu S Ajith
<br><a href="https://github.com/manusajith/" title="Github">GitHub</a> | <a href="https://twitter.com/manusajith/" title="Twitter">Twitter</a></p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/manusajith/caching_demo_app/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/manusajith/caching_demo_app/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/manusajith/caching_demo_app"></a> is maintained by <a href="https://github.com/manusajith">manusajith</a>.</p>

          <p>This page was generated by <a href="pages.github.com">GitHub Pages</a> using the Architect theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>